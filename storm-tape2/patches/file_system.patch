*** Begin Patch
*** Add File: src/io_utils.hpp
+// io_utils.hpp - small helper: parallel_map / parallel_for_each with bounded concurrency
+// Conservative implementation using std::async + batching to limit concurrent tasks.
+#pragma once
+
+#include <future>
+#include <vector>
+#include <thread>
+#include <iterator>
+#include <type_traits>
+#include <algorithm>
+#include <cstddef>
+
+namespace storm::io_utils {
+
+// Determine result type for invoking Fn on reference to iterator value
+template <typename Iter, typename Fn>
+using invoke_result_t_iter = std::invoke_result_t<Fn, typename std::iterator_traits<Iter>::reference>;
+
+// parallel_map: apply fn to each element in [begin, end), return vector of results.
+// Concurrency: at most 'concurrency' tasks are scheduled concurrently.
+template <typename Iter, typename Fn>
+auto parallel_map(Iter begin, Iter end, Fn fn, std::size_t concurrency = 0)
+    -> std::vector<invoke_result_t_iter<Iter, Fn>>
+{
+    using result_t = invoke_result_t_iter<Iter, Fn>;
+
+    if (concurrency == 0) {
+        auto hc = std::thread::hardware_concurrency();
+        concurrency = (hc == 0) ? 2u : std::max(2u, hc);
+    }
+
+    std::vector<result_t> results;
+    auto dist = std::distance(begin, end);
+    results.reserve(static_cast<std::size_t>(dist));
+
+    std::vector<std::future<result_t>> futures;
+    futures.reserve(std::min<std::size_t>(static_cast<std::size_t>(dist), concurrency));
+
+    for (auto it = begin; it != end; ++it) {
+        futures.push_back(std::async(std::launch::async, fn, std::ref(*it)));
+        if (futures.size() >= concurrency) {
+            for (auto &f : futures) {
+                results.push_back(f.get());
+            }
+            futures.clear();
+        }
+    }
+    for (auto &f : futures) {
+        results.push_back(f.get());
+    }
+
+    return results;
+}
+
+// parallel_for_each: run fn for side-effects, no results collected
+template <typename Iter, typename Fn>
+void parallel_for_each(Iter begin, Iter end, Fn fn, std::size_t concurrency = 0)
+{
+    if (concurrency == 0) {
+        auto hc = std::thread::hardware_concurrency();
+        concurrency = (hc == 0) ? 2u : std::max(2u, hc);
+    }
+
+    std::vector<std::future<void>> futures;
+    futures.reserve(std::min<std::size_t>(static_cast<std::size_t>(std::distance(begin, end)), concurrency));
+
+    for (auto it = begin; it != end; ++it) {
+        futures.push_back(std::async(std::launch::async, fn, std::ref(*it)));
+        if (futures.size() >= concurrency) {
+            for (auto &f : futures) f.get();
+            futures.clear();
+        }
+    }
+    for (auto &f : futures) f.get();
+}
+
+} // namespace storm::io_utils
+
*** End Patch
*** Begin Patch
*** Update File: src/tape_service.cpp
@@
 ArchiveInfoResponse TapeService::archive_info(ArchiveInfoRequest info)
 {
   TRACE_FUNCTION();
 
   PathInfos infos;
   auto& paths = info.paths;
   infos.reserve(paths.size());
 
   StorageAreaResolver resolve{m_config.storage_areas};
-
-  std::transform( //
-      paths.begin(), paths.end(), std::back_inserter(infos),
-      [&](LogicalPath& logical_path) {
-        using namespace std::string_literals;
-
-        auto const physical_path = resolve(logical_path);
-
-        std::error_code ec;
-        auto status = fs::status(physical_path, ec);
-
-        // if the file doesn't exist, fs::status sets ec, so check first for
-        // existence
-        if (!fs::exists(status)) {
-          return PathInfo{std::move(logical_path),
-                          "No such file or directory"s};
-        }
-        if (ec != std::error_code{}) {
-          return PathInfo{std::move(logical_path), Locality::unavailable};
-        }
-        if (fs::is_directory(status)) {
-          return PathInfo{std::move(logical_path), "Is a directory"s};
-        }
-        if (!fs::is_regular_file(status)) {
-          return PathInfo{std::move(logical_path), "Not a regular file"s};
-        }
-        auto locality = ExtendedFileStatus{m_storage, physical_path}.locality();
-        override_locality(locality, physical_path);
-        return PathInfo{std::move(logical_path), locality};
-      });
+  // Use a bounded parallel map to evaluate filesystem queries and build PathInfo.
+  // The lambda returns PathInfo for each logical_path.
+  auto concurrency = std::max<std::size_t>(2u, std::thread::hardware_concurrency());
+  auto local_infos = storm::io_utils::parallel_map(
+      paths.begin(), paths.end(),
+      [this, &resolve](LogicalPath& logical_path) -> PathInfo {
+        using namespace std::string_literals;
+        auto const physical_path = resolve(logical_path);
+
+        std::error_code ec;
+        auto status = fs::status(physical_path, ec);
+
+        // if the file doesn't exist, fs::status sets ec, so check first for
+        // existence
+        if (!fs::exists(status)) {
+          return PathInfo{std::move(logical_path), "No such file or directory"s};
+        }
+        if (ec != std::error_code{}) {
+          return PathInfo{std::move(logical_path), Locality::unavailable};
+        }
+        if (fs::is_directory(status)) {
+          return PathInfo{std::move(logical_path), "Is a directory"s};
+        }
+        if (!fs::is_regular_file(status)) {
+          return PathInfo{std::move(logical_path), "Not a regular file"s};
+        }
+        auto locality = ExtendedFileStatus{m_storage, physical_path}.locality();
+        override_locality(locality, physical_path);
+        return PathInfo{std::move(logical_path), locality};
+      },
+      concurrency);
+
+  // Move all results into infos (order matches input order)
+  infos.insert(infos.end(),
+               std::make_move_iterator(local_infos.begin()),
+               std::make_move_iterator(local_infos.end()));
@@
-  for (auto&& path : paths) {
-    auto const locality = ExtendedFileStatus{storage, path}.locality();
-    path_localities.emplace_back(std::move(path), locality);
-  }
+  // Parallelize computing localities for a set of paths (I/O bound).
+  auto path_loc_results = storm::io_utils::parallel_map(
+      paths.begin(), paths.end(),
+      [&storage](PhysicalPath& path) -> PathLocality {
+        auto const locality = ExtendedFileStatus{storage, path}.locality();
+        return PathLocality{std::move(path), locality};
+      },
+      std::max<std::size_t>(2u, std::thread::hardware_concurrency()));
+
+  for (auto &pl : path_loc_results) {
+    path_localities.emplace_back(std::move(pl));
+  }
@@
-    std::for_each(
-        physical_paths.begin(), physical_paths.end(), [&](auto& physical_path) {
-          XAttrName const tsm_rect{"user.TSMRecT"};
-          std::error_code ec;
-          create_xattr(physical_path, tsm_rect, ec);
-          if (ec != std::error_code{}) {
-            CROW_LOG_WARNING << fmt::format("Cannot create xattr {} for file {}",
-                                            tsm_rect.value(),
-                                            physical_path);
-          }
-        });
+    // parallelize xattr creation with bounded concurrency (I/O-bound)
+    storm::io_utils::parallel_for_each(
+        physical_paths.begin(), physical_paths.end(),
+        [](PhysicalPath& physical_path) {
+          XAttrName const tsm_rect{"user.TSMRecT"};
+          std::error_code ec;
+          create_xattr(physical_path, tsm_rect, ec);
+          if (ec != std::error_code{}) {
+            CROW_LOG_WARNING << fmt::format("Cannot create xattr {} for file {}",
+                                            tsm_rect.value(), physical_path);
+          }
+        },
+        std::max<std::size_t>(2u, std::thread::hardware_concurrency()));
@@ StatusResponse TapeService::status(StageId const& id)
-    for (auto& files = stage.files; auto& file : files) {
-      ExtendedFileStatus file_status{m_storage, file.physical_path};
+    // --- PARALLEL status â†’ ExtendedFileStatus ---
+    {
+      auto &files = stage.files;
+      std::mutex up_mtx;
+
+      auto worker = [&](File &file) {
+        ExtendedFileStatus fs_info{m_storage, file.physical_path};
+        return std::pair<File*, ExtendedFileStatus>(std::addressof(file),
+                                                    std::move(fs_info));
+      };
+
+      auto results = storm::io_utils::parallel_map(
+          files.begin(), files.end(), worker,
+          std::max(4u, std::thread::hardware_concurrency() / 2));
+
+      for (auto &pr : results) {
+        File &file = *pr.first;
+        ExtendedFileStatus &file_status = pr.second;
 
         switch (file.state) {
         case File::State::started:
             ...
*** End Patch
