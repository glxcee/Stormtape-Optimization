*** Begin Patch: tape_service_par.patch
*** Update File: ../src/tape_service.cpp
@@
-  StorageAreaResolver resolve{m_config.storage_areas};
-  for (auto& file : files) {
-    file.physical_path = resolve(file.logical_path);
-    std::error_code ec;
-    auto status = fs::status(file.physical_path, ec);
-    if (ec || !fs::is_regular_file(status)) {
-      file.state       = File::State::failed;
-      file.started_at  = std::time(nullptr);
-      file.finished_at = file.started_at;
-    }
-  }
+  // Parallelize resolution and quick filesystem checks: each element is independent.
+  // We instantiate a resolver locally inside the lambda to be safe for concurrent use.
+  #include <execution>
+  std::for_each(std::execution::par, files.begin(), files.end(),
+                [this](File &file) {
+                  StorageAreaResolver resolver{m_config.storage_areas};
+                  file.physical_path = resolver(file.logical_path);
+                  std::error_code ec;
+                  auto status = fs::status(file.physical_path, ec);
+                  if (ec || !fs::is_regular_file(status)) {
+                    file.state       = File::State::failed;
+                    file.started_at  = std::time(nullptr);
+                    file.finished_at = file.started_at;
+                  }
+                });
@@
- std::sort(files.begin(), files.end(), [](File const& a, File const& b) {
+ std::sort(std::execution::par, files.begin(), files.end(), [](File const& a, File const& b) {
@@
- std::sort(stage.files.begin(), stage.files.end(),
+ std::sort(std::execution::par, stage.files.begin(), stage.files.end(),
@@
- std::sort(paths.begin(), paths.end());
+ std::sort(std::execution::par, paths.begin(), paths.end());
@@
-  std::transform( //
-      paths.begin(), paths.end(), std::back_inserter(infos),
-      [&](LogicalPath& logical_path) {
-        using namespace std::string_literals;
-
-        auto const physical_path = resolve(logical_path);
-   std::error_code ec;
-        auto status = fs::status(physical_path, ec);
-
-        // if the file doesn't exist, fs::status sets ec, so check first for
-        // existence
-        if (!fs::exists(status)) {
-          return PathInfo{std::move(logical_path),
-                          "No such file or directory"s};
-        }
-        if (ec != std::error_code{}) {
-          return PathInfo{std::move(logical_path), Locality::unavailable};
-        }
-        if (fs::is_directory(status)) {
-          return PathInfo{std::move(logical_path), "Is a directory"s};
-        }
-        if (!fs::is_regular_file(status)) {
-          return PathInfo{std::move(logical_path), "Not a regular file"s};
-        }
-        auto locality = ExtendedFileStatus{m_storage, physical_path}.locality();
-        override_locality(locality, physical_path);
-        return PathInfo{std::move(logical_path), locality};
-      });
+  
@@
- path_localities.reserve(paths.size());
-
-  for (auto&& path : paths) {
-    auto const locality = ExtendedFileStatus{storage, path}.locality();
-    path_localities.emplace_back(std::move(path), locality);
-  }
+p ath_localities.resize(paths.size());
+
+  std::transform(std::execution::par, paths.begin(), paths.end(),
+                  path_localities.begin(), [&](PhysicalPath& path) {
+                  auto const locality =
+                  ExtendedFileStatus{storage, path}.locality();
+                  return PathLocality{std::move(path), locality};
+                });
